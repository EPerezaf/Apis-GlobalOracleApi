# GlobalOracleAPI - Cursor Rules

## üìö Documentaci√≥n
La documentaci√≥n completa est√° en `docs/`:
- `docs/ARCHITECTURE.md` - Arquitectura y estrategia
- `docs/MODULE_TEMPLATE.md` - Plantilla para crear m√≥dulos
- `docs/CODING_CONVENTIONS.md` - Convenciones de c√≥digo

## üèóÔ∏è Arquitectura del Proyecto

### Estructura de Carpetas
```
src/
‚îú‚îÄ‚îÄ Companies/                    # APIs espec√≠ficas por empresa
‚îÇ   ‚îî‚îÄ‚îÄ {Company}/                # GM, Jetour, Nissan, etc.
‚îÇ       ‚îî‚îÄ‚îÄ {Module}/             # CatalogSync, Sales, PostSales, etc.
‚îÇ           ‚îú‚îÄ‚îÄ {Company}.{Module}.API
‚îÇ           ‚îú‚îÄ‚îÄ {Company}.{Module}.Application
‚îÇ           ‚îú‚îÄ‚îÄ {Company}.{Module}.Domain
‚îÇ           ‚îî‚îÄ‚îÄ {Company}.{Module}.Infrastructure
‚îÇ
‚îî‚îÄ‚îÄ Shared/                       # Funcionalidades compartidas
    ‚îú‚îÄ‚îÄ Shared.Contracts/         # DTOs, Responses comunes
    ‚îú‚îÄ‚îÄ Shared.Exceptions/       # Excepciones base
    ‚îú‚îÄ‚îÄ Shared.Security/          # JWT, Autenticaci√≥n
    ‚îî‚îÄ‚îÄ Shared.Infrastructure/    # Conexiones, Factories
```

### Principios Fundamentales
1. **Separaci√≥n por Dominio de Negocio** - NO por tecnolog√≠a
2. **50-100 endpoints por m√≥dulo** (ideal)
3. **Modular Monolith** - Un solo deploy, m√≥dulos aislados
4. **Estructura:** `Companies ‚Üí {Company} ‚Üí {Module} ‚Üí {Layers}`
5. **ORM:** Dapper (micro-ORM) - NO Entity Framework ni ADO.NET puro

## üè∑Ô∏è Nomenclatura

### Proyectos (.csproj)
**Formato:** `{Company}.{Module}.{Layer}`

Ejemplos:
- `GM.CatalogSync.API`
- `GM.CatalogSync.Application`
- `GM.CatalogSync.Domain`
- `GM.CatalogSync.Infrastructure`
- `Jetour.Sales.API`

### Carpetas F√≠sicas
**Formato:** `src/Companies/{Company}/{Module}/{Project}`

Ejemplo:
- `src/Companies/GM/CatalogSync/GM.CatalogSync.API/`

### Namespaces
**Formato:** `{Company}.{Module}.{Layer}`

Ejemplo:
```csharp
namespace GM.CatalogSync.API.Controllers;
namespace GM.CatalogSync.Application.Services;
namespace GM.CatalogSync.Domain.Entities;
```

### Clases y Archivos
- **Clases:** `PascalCase` - `OrderService`, `ProductRepository`
- **Interfaces:** `I` + `PascalCase` - `IOrderService`, `IProductRepository`
- **DTOs:** `{Action}{Entity}Dto` - `CreateOrderDto`, `UpdateOrderDto`, `OrderDto`
- **M√©todos:** `PascalCase` con sufijo `Async` - `GetOrderByIdAsync`, `CreateOrderAsync`
- **Variables:** `camelCase` - `orderService`, `orderId`

## üì¶ Estructura de Capas

### API Layer
- **Ubicaci√≥n:** `{Company}.{Module}.API/Controllers/`
- **Responsabilidad:** Controllers, Endpoints, Validaci√≥n de entrada
- **Dependencias:** Application, Domain, Shared.*

**Estructura:**
```
API/
‚îú‚îÄ‚îÄ Controllers/
‚îÇ   ‚îî‚îÄ‚îÄ {Entity}Controller.cs
‚îú‚îÄ‚îÄ Program.cs
‚îî‚îÄ‚îÄ appsettings.json
```

### Application Layer
- **Ubicaci√≥n:** `{Company}.{Module}.Application/`
- **Responsabilidad:** L√≥gica de negocio, DTOs, Servicios
- **Dependencias:** Domain, Shared.*

**Estructura:**
```
Application/
‚îú‚îÄ‚îÄ DTOs/
‚îÇ   ‚îú‚îÄ‚îÄ {Entity}Dto.cs
‚îÇ   ‚îú‚îÄ‚îÄ Create{Entity}Dto.cs
‚îÇ   ‚îî‚îÄ‚îÄ Update{Entity}Dto.cs
‚îú‚îÄ‚îÄ Services/
‚îÇ   ‚îú‚îÄ‚îÄ I{Entity}Service.cs
‚îÇ   ‚îî‚îÄ‚îÄ {Entity}Service.cs
‚îî‚îÄ‚îÄ Exceptions/
    ‚îî‚îÄ‚îÄ {Entity}Exceptions.cs
```

### Domain Layer
- **Ubicaci√≥n:** `{Company}.{Module}.Domain/`
- **Responsabilidad:** Entidades, Interfaces de repositorio, Reglas de negocio
- **Dependencias:** Solo Shared.Contracts (si es necesario)

**Estructura:**
```
Domain/
‚îú‚îÄ‚îÄ Entities/
‚îÇ   ‚îî‚îÄ‚îÄ {Entity}.cs
‚îú‚îÄ‚îÄ Interfaces/
‚îÇ   ‚îî‚îÄ‚îÄ I{Entity}Repository.cs
‚îî‚îÄ‚îÄ ValueObjects/
```

### Infrastructure Layer
- **Ubicaci√≥n:** `{Company}.{Module}.Infrastructure/`
- **Responsabilidad:** Repositorios, Acceso a datos, Integraciones externas
- **Dependencias:** Domain, Shared.Infrastructure

**Estructura:**
```
Infrastructure/
‚îî‚îÄ‚îÄ Repositories/
    ‚îî‚îÄ‚îÄ {Entity}Repository.cs
```

## üõ£Ô∏è Convenciones de Controllers

### Route Attributes
**Formato:** `/api/v{version}/{company}/{module}/{resource}`

Ejemplo:
```csharp
[ApiController]
[Route("api/v1/gm/catalog-sync/products")]
public class ProductsController : ControllerBase
```

### M√©todos HTTP
- `[HttpGet]` - GET /api/v1/gm/catalog-sync/products
- `[HttpGet("{id}")]` - GET /api/v1/gm/catalog-sync/products/{id}
- `[HttpPost]` - POST /api/v1/gm/catalog-sync/products
- `[HttpPut("{id}")]` - PUT /api/v1/gm/catalog-sync/products/{id}
- `[HttpPatch("{id}")]` - PATCH /api/v1/gm/catalog-sync/products/{id}
- `[HttpDelete("{id}")]` - DELETE /api/v1/gm/catalog-sync/products/{id}

### Respuestas
**SIEMPRE usar `ApiResponse<T>` de Shared.Contracts:**

```csharp
[HttpGet]
public async Task<ActionResult<ApiResponse<List<ProductDto>>>> GetProducts()
{
    var products = await _productService.GetAllProductsAsync();
    return Ok(ApiResponse<List<ProductDto>>.Success(products));
}

[HttpGet("{id}")]
public async Task<ActionResult<ApiResponse<ProductDto>>> GetProduct(int id)
{
    var product = await _productService.GetProductByIdAsync(id);
    if (product == null)
    {
        return NotFound(ApiResponse<ProductDto>.Error("Product not found"));
    }
    return Ok(ApiResponse<ProductDto>.Success(product));
}

[HttpPost]
public async Task<ActionResult<ApiResponse<ProductDto>>> CreateProduct([FromBody] CreateProductDto dto)
{
    try
    {
        var product = await _productService.CreateProductAsync(dto);
        return CreatedAtAction(nameof(GetProduct), new { id = product.Id }, 
            ApiResponse<ProductDto>.Success(product));
    }
    catch (BusinessValidationException ex)
    {
        return BadRequest(ApiResponse<ProductDto>.Error(ex.Message));
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Error creating product");
        return StatusCode(500, ApiResponse<ProductDto>.Error("Internal server error"));
    }
}
```

### Paginaci√≥n en GET (OBLIGATORIO)
**TODOS los endpoints GET que devuelven listas DEBEN incluir paginaci√≥n y timestamp:**

#### Estructura de Respuesta Requerida
```json
{
  "success": true,
  "message": "...",
  "data": [...],
  "pagination": {
    "page": 1,
    "pageSize": 200,
    "totalRecords": 42,
    "totalPages": 5
  },
  "timestamp": "2025-11-03T22:28:23Z"
}
```

#### Implementaci√≥n en Controller
```csharp
[HttpGet]
[ProducesResponseType(typeof(ApiResponse<List<ProductDto>>), 200)]
public async Task<IActionResult> ObtenerProductos(
    [FromQuery] string? filtro = null,
    [FromQuery] int page = 1,
    [FromQuery] int pageSize = 200)
{
    var correlationId = CorrelationHelper.GetCorrelationId(HttpContext);
    var stopwatch = Stopwatch.StartNew();

    try
    {
        // El servicio debe retornar (List<T> data, int totalRecords)
        var (data, totalRecords) = await _service.ObtenerConFiltrosAsync(filtro, page, pageSize);

        int totalPages = (int)Math.Ceiling((double)totalRecords / pageSize);

        stopwatch.Stop();
        _logger.LogInformation(
            "Productos obtenidos. CorrelationId: {CorrelationId}, Tiempo: {ElapsedMs}ms, Registros: {Count} de {Total}, P√°gina: {Page} de {TotalPages}",
            correlationId, stopwatch.ElapsedMilliseconds, data.Count, totalRecords, page, totalPages);

        return Ok(new ApiResponse<List<ProductDto>>
        {
            Success = true,
            Message = data.Count > 0
                ? $"Registros obtenidos exitosamente (P√°gina {page} de {totalPages})"
                : "No se encontraron registros que coincidan con los filtros",
            Data = data,
            Pagination = new PaginationInfo
            {
                Page = page,
                PageSize = pageSize,
                TotalRecords = totalRecords,
                TotalPages = totalPages
            },
            Timestamp = DateTimeHelper.GetMexicoTimeString()
        });
    }
    catch (Exception ex)
    {
        stopwatch.Stop();
        _logger.LogError(ex, "Error al obtener productos");
        return StatusCode(500, new ApiResponse
        {
            Success = false,
            Message = "Error interno del servidor",
            Timestamp = DateTimeHelper.GetMexicoTimeString()
        });
    }
}
```

#### Implementaci√≥n en Service
```csharp
public interface IProductService
{
    Task<(List<ProductDto> data, int totalRecords)> ObtenerConFiltrosAsync(
        string? filtro = null,
        int page = 1,
        int pageSize = 200);
}

public class ProductService : IProductService
{
    public async Task<(List<ProductDto> data, int totalRecords)> ObtenerConFiltrosAsync(
        string? filtro = null,
        int page = 1,
        int pageSize = 200)
    {
        var (entidades, totalRecords) = await _repository.ObtenerConFiltrosAsync(filtro, page, pageSize);
        var dtos = entidades.Select(MapearADto).ToList();
        return (dtos, totalRecords);
    }
}
```

#### Implementaci√≥n en Repository
```csharp
public interface IProductRepository
{
    Task<(List<Product> data, int totalRecords)> ObtenerConFiltrosAsync(
        string? filtro = null,
        int page = 1,
        int pageSize = 200);
}

public class ProductRepository : IProductRepository
{
    public async Task<(List<Product> data, int totalRecords)> ObtenerConFiltrosAsync(
        string? filtro = null,
        int page = 1,
        int pageSize = 200)
    {
        using var connection = await _connectionFactory.CreateConnectionAsync();
        
        var parameters = new DynamicParameters();
        var whereClause = "WHERE 1=1";

        if (!string.IsNullOrWhiteSpace(filtro))
        {
            whereClause += " AND UPPER(Nombre) LIKE UPPER(:Filtro)";
            parameters.Add("Filtro", $"%{filtro}%");
        }

        // Obtener total de registros
        var countSql = $"SELECT COUNT(*) FROM {TABLA} {whereClause}";
        var totalRecords = await connection.ExecuteScalarAsync<int>(countSql, parameters);

        if (totalRecords == 0)
        {
            return (new List<Product>(), 0);
        }

        // Aplicar paginaci√≥n
        int offset = (page - 1) * pageSize;
        parameters.Add("offset", offset);
        parameters.Add("limit", offset + pageSize);

        var sql = $@"
            SELECT * FROM (
                SELECT 
                    Id, Nombre, Status,
                    ROW_NUMBER() OVER (ORDER BY Id DESC) AS RNUM
                FROM {TABLA}
                {whereClause}
            ) WHERE RNUM > :offset AND RNUM <= :limit";

        var resultados = await connection.QueryAsync<Product>(sql, parameters);
        var lista = resultados.ToList();

        return (lista, totalRecords);
    }
}
```

#### Reglas de Paginaci√≥n
- ‚úÖ **TODOS los GET que devuelven listas** deben incluir `Pagination` y `Timestamp`
- ‚úÖ **Par√°metros por defecto:** `page = 1`, `pageSize = 200`
- ‚úÖ **GET por ID** (devuelve un solo objeto) solo necesita `Timestamp`, NO paginaci√≥n
- ‚úÖ **Endpoints de estad√≠sticas/monitoreo** solo necesitan `Timestamp`, NO paginaci√≥n
- ‚úÖ **Calcular `totalPages`** usando `Math.Ceiling((double)totalRecords / pageSize)`
- ‚úÖ **Usar `ROW_NUMBER()` en Oracle** para paginaci√≥n eficiente
- ‚úÖ **Incluir `totalRecords`** en la respuesta para que el cliente sepa el total

#### Ejemplo de Respuesta JSON
```json
{
  "success": true,
  "message": "Registros obtenidos exitosamente (P√°gina 1 de 5)",
  "data": [
    {
      "id": 1,
      "nombre": "Producto 1"
    },
    {
      "id": 2,
      "nombre": "Producto 2"
    }
  ],
  "pagination": {
    "page": 1,
    "pageSize": 200,
    "totalRecords": 42,
    "totalPages": 5
  },
  "timestamp": "2025-11-03T22:28:23Z"
}
```

## üîÑ Convenciones de Servicios

### Interfaces
```csharp
public interface I{Entity}Service
{
    Task<{Entity}Dto?> Get{Entity}ByIdAsync(int id);
    Task<List<{Entity}Dto>> GetAll{Entity}sAsync();
    Task<{Entity}Dto> Create{Entity}Async(Create{Entity}Dto dto);
    Task<{Entity}Dto> Update{Entity}Async(int id, Update{Entity}Dto dto);
    Task Delete{Entity}Async(int id);
}
```

### Implementaci√≥n
```csharp
public class {Entity}Service : I{Entity}Service
{
    private readonly I{Entity}Repository _repository;
    private readonly ILogger<{Entity}Service> _logger;

    public {Entity}Service(I{Entity}Repository repository, ILogger<{Entity}Service> logger)
    {
        _repository = repository;
        _logger = logger;
    }

    public async Task<{Entity}Dto?> Get{Entity}ByIdAsync(int id)
    {
        // Implementaci√≥n
    }
}
```

### Registro en Program.cs
```csharp
builder.Services.AddScoped<I{Entity}Repository, {Entity}Repository>();
builder.Services.AddScoped<I{Entity}Service, {Entity}Service>();
```

## üóÑÔ∏è Convenciones de Repositorios

### üîß ORM: Dapper (OBLIGATORIO)
**SIEMPRE usar Dapper como micro-ORM para acceso a datos. NO usar Entity Framework ni ADO.NET puro (OracleCommand).**

#### ¬øPor qu√© Dapper?
- ‚úÖ Alto rendimiento (cercano a ADO.NET puro)
- ‚úÖ Mapeo autom√°tico de resultados a objetos
- ‚úÖ Soporte nativo para par√°metros y transacciones
- ‚úÖ Control total sobre las queries SQL
- ‚úÖ Ideal para Oracle con `Oracle.ManagedDataAccess.Core`

#### Dependencias requeridas
```xml
<PackageReference Include="Dapper" Version="2.1.*" />
<PackageReference Include="Oracle.ManagedDataAccess.Core" Version="23.*" />
```

### Interfaces
```csharp
public interface I{Entity}Repository
{
    Task<{Entity}?> GetByIdAsync(int id);
    Task<List<{Entity}>> GetAllAsync();
    Task<{Entity}> CreateAsync({Entity} entity);
    Task<{Entity}> UpdateAsync({Entity} entity);
    Task DeleteAsync(int id);
}
```

### Implementaci√≥n con Dapper + Oracle
**SIEMPRE usar Dapper con `using` para conexiones Oracle:**

```csharp
using Dapper;
using Oracle.ManagedDataAccess.Client;

public class {Entity}Repository : I{Entity}Repository
{
    private readonly IOracleConnectionFactory _connectionFactory;
    private readonly ILogger<{Entity}Repository> _logger;

    public {Entity}Repository(IOracleConnectionFactory connectionFactory, ILogger<{Entity}Repository> logger)
    {
        _connectionFactory = connectionFactory;
        _logger = logger;
    }

    public async Task<{Entity}?> GetByIdAsync(int id)
    {
        const string sql = @"
            SELECT Id, Name, Status, UsuarioInserto, FechaInsercion, 
                   UltimoUsuarioActualizo as UltimoUsuarioActualizo, FechaActualizacion
            FROM {TableName}
            WHERE Id = :Id";

        try
        {
            _logger.LogInformation("üóÑÔ∏è [REPOSITORY] Obteniendo {Entity} por ID: {Id}", id);

            using var connection = await _connectionFactory.CreateConnectionAsync();

            // Dapper mapea autom√°ticamente las columnas a propiedades
            var resultado = await connection.QueryFirstOrDefaultAsync<{Entity}>(sql, new { Id = id });

            if (resultado == null)
            {
                _logger.LogWarning("‚ö†Ô∏è [REPOSITORY] Entidad {EntityId} no encontrada", id);
                return null;
            }

            _logger.LogInformation("‚úÖ [REPOSITORY] Entidad {EntityId} obtenida exitosamente", id);
            return resultado;
        }
        catch (OracleException ex)
        {
            _logger.LogError(ex, "‚ùå [REPOSITORY] Error Oracle en {Method}. ErrorCode: {ErrorCode}",
                nameof(GetByIdAsync), ex.Number);
            throw new DataAccessException("Error al acceder a la base de datos", ex);
        }
    }

    public async Task<List<{Entity}>> GetAllAsync()
    {
        const string sql = @"
            SELECT Id, Name, Status, UsuarioInserto, FechaInsercion, 
                   UltimoUsuarioActualizo, FechaActualizacion
            FROM {TableName}
            ORDER BY Id DESC";

        try
        {
            _logger.LogInformation("üóÑÔ∏è [REPOSITORY] Obteniendo todos los registros de {Entity}");

            using var connection = await _connectionFactory.CreateConnectionAsync();

            var resultados = await connection.QueryAsync<{Entity}>(sql);
            var lista = resultados.ToList();

            _logger.LogInformation("‚úÖ [REPOSITORY] {Cantidad} registros obtenidos", lista.Count);
            return lista;
        }
        catch (OracleException ex)
        {
            _logger.LogError(ex, "‚ùå [REPOSITORY] Error Oracle en {Method}. ErrorCode: {ErrorCode}",
                nameof(GetAllAsync), ex.Number);
            throw new DataAccessException("Error al acceder a la base de datos", ex);
        }
    }

    public async Task<{Entity}> CreateAsync({Entity} entity, string currentUser)
    {
        const string sql = @"
            INSERT INTO {TableName} (Name, Status, UsuarioInserto)
            VALUES (:Name, :Status, :UsuarioInserto)
            RETURNING Id INTO :Id";

        try
        {
            _logger.LogInformation("üóÑÔ∏è [REPOSITORY] Creando entidad {EntityName} por usuario {User}",
                entity.Name, currentUser);

            using var connection = await _connectionFactory.CreateConnectionAsync();

            // Usar DynamicParameters para manejar par√°metros de salida (RETURNING INTO)
            var parameters = new DynamicParameters();
            parameters.Add("Name", entity.Name);
            parameters.Add("Status", entity.Status);
            parameters.Add("UsuarioInserto", currentUser);
            parameters.Add("Id", dbType: System.Data.DbType.Int32, direction: System.Data.ParameterDirection.Output);

            await connection.ExecuteAsync(sql, parameters);

            entity.Id = parameters.Get<int>("Id");

            _logger.LogInformation("‚úÖ [REPOSITORY] Entidad {EntityId} creada exitosamente", entity.Id);
            return entity;
        }
        catch (OracleException ex)
        {
            _logger.LogError(ex, "‚ùå [REPOSITORY] Error Oracle al crear entidad. ErrorCode: {ErrorCode}",
                ex.Number);
            throw new DataAccessException("Error al crear la entidad en la base de datos", ex);
        }
    }
}
```

### üìö M√©todos principales de Dapper

| M√©todo | Uso |
|--------|-----|
| `QueryAsync<T>` | Obtener m√∫ltiples registros |
| `QueryFirstOrDefaultAsync<T>` | Obtener un registro o null |
| `ExecuteAsync` | INSERT, UPDATE, DELETE |
| `ExecuteScalarAsync<T>` | Obtener un valor escalar (COUNT, SUM, etc.) |
| `DynamicParameters` | Manejar par√°metros de entrada/salida |

### üîÑ Transacciones con Dapper

```csharp
using var connection = await _connectionFactory.CreateConnectionAsync();
using var transaction = connection.BeginTransaction();

try
{
    // Operaci√≥n 1
    await connection.ExecuteAsync(sqlUpdate, parametros1, transaction);
    
    // Operaci√≥n 2
    await connection.ExecuteAsync(sqlInsert, parametros2, transaction);
    
    transaction.Commit();
    _logger.LogInformation("‚úÖ Transacci√≥n completada exitosamente");
}
catch (Exception)
{
    transaction.Rollback();
    _logger.LogError("‚ùå Rollback ejecutado");
    throw;
}
```

### ‚ö†Ô∏è Reglas Cr√≠ticas para Dapper + Oracle

**‚úÖ SIEMPRE hacer:**
- Usar `using var connection = await _connectionFactory.CreateConnectionAsync();`
- Usar Dapper (`QueryAsync`, `ExecuteAsync`) en lugar de `OracleCommand`
- Parametrizar TODAS las consultas con objetos an√≥nimos o `DynamicParameters`
- Usar alias en SELECT para mapear a propiedades de la entidad
- Usar transacciones para operaciones m√∫ltiples
- Cerrar conexiones con `using` (autom√°tico)

**‚ùå NUNCA hacer:**
```csharp
// ‚ùå SQL Injection vulnerability
string sql = $"SELECT * FROM Users WHERE Id = {id}";

// ‚ùå Usar OracleCommand en lugar de Dapper
using var command = new OracleCommand(sql, connection);

// ‚ùå Conexi√≥n sin using
var connection = new OracleConnection(_connectionString);
connection.Open();
// ¬°Conexi√≥n nunca se cierra!

// ‚ùå Sin parametrizar
var sql = $"SELECT * FROM Users WHERE Id = {id}";
await connection.QueryAsync<User>(sql);
```

## üìä Convenciones de DTOs

### Naming
- `{Entity}Dto` - Para lectura
- `Create{Entity}Dto` - Para creaci√≥n
- `Update{Entity}Dto` - Para actualizaci√≥n
- `{Entity}SummaryDto` - Para res√∫menes

### Estructura
```csharp
public class Create{Entity}Dto
{
    [Required]
    public int Property1 { get; set; }

    [Required]
    [MinLength(1)]
    public string Property2 { get; set; } = string.Empty;

    public string? OptionalProperty { get; set; }
}
```

### ‚ö†Ô∏è Reglas Cr√≠ticas para DTOs de Creaci√≥n

**‚ùå NUNCA incluir en DTOs de creaci√≥n (`Create{Entity}Dto`):**
- ‚ùå **Fechas** (FechaCarga, FechaRegistro, FechaSincronizacion, FechaAlta, FechaModificacion, etc.)
  - Todas las fechas se calculan autom√°ticamente en el servicio usando `DateTimeHelper.GetMexicoDateTime()`
- ‚ùå **Usuarios** (UsuarioAlta, UsuarioModificacion, UsuarioRegistro, etc.)
  - Todos los usuarios se toman del JWT token en el controller usando `JwtUserHelper.GetCurrentUser()`
- ‚ùå **IDs generados autom√°ticamente** (Id, {Entity}Id, etc.)
  - Se generan por secuencias de Oracle o auto-increment

**‚úÖ SIEMPRE hacer:**
- ‚úÖ Calcular fechas autom√°ticamente en el servicio usando `DateTimeHelper.GetMexicoDateTime()`
- ‚úÖ Tomar usuarios del JWT en el controller y pasarlos al servicio
- ‚úÖ Documentar en XML que estos campos son calculados autom√°ticamente
- ‚úÖ Agregar comentarios en el DTO indicando que el campo se calcula autom√°ticamente

**Ejemplo correcto:**
```csharp
// ‚ùå INCORRECTO - DTO con fecha y usuario
public class CrearCargaArchivoDto
{
    [Required]
    public string Proceso { get; set; } = string.Empty;
    
    [Required]
    public DateTime FechaCarga { get; set; } // ‚ùå NO debe estar aqu√≠
    
    public string UsuarioAlta { get; set; } = string.Empty; // ‚ùå NO debe estar aqu√≠
}

// ‚úÖ CORRECTO - DTO sin fecha ni usuario
public class CrearCargaArchivoDto
{
    [Required]
    public string Proceso { get; set; } = string.Empty;
    
    // NOTA: FechaCarga se calcula autom√°ticamente en el servicio (no se env√≠a en el request)
    // NOTA: UsuarioAlta se toma del JWT token (no se env√≠a en el request)
}

// ‚úÖ CORRECTO - Service calcula fecha autom√°ticamente
public async Task<CargaArchivoDto> CrearAsync(CrearCargaArchivoDto dto, string usuarioAlta)
{
    var entidad = new CargaArchivo
    {
        Proceso = dto.Proceso,
        FechaCarga = DateTimeHelper.GetMexicoDateTime(), // ‚úÖ Calculado autom√°ticamente
        UsuarioAlta = usuarioAlta // ‚úÖ Viene del JWT (pasado desde el controller)
    };
    // ...
}

// ‚úÖ CORRECTO - Controller toma usuario del JWT
[HttpPost]
public async Task<IActionResult> Crear([FromBody] CrearCargaArchivoDto dto)
{
    var userId = JwtUserHelper.GetCurrentUser(User, _logger); // ‚úÖ Usuario del JWT
    var resultado = await _service.CrearAsync(dto, userId);
    // ...
}
```

## üèóÔ∏è Convenciones de Entidades

### Estructura con Auditor√≠a
**Cada entidad debe incluir campos de auditor√≠a:**

```csharp
public class {Entity}
{
    public int Id { get; set; }
    public int ForeignKeyId { get; set; }
    
    // Campos de auditor√≠a (requeridos)
    public string UsuarioInserto { get; set; } = string.Empty;
    public DateTime FechaInsercion { get; set; }
    public string? UltimoUsuarioActualizo { get; set; }
    public DateTime? FechaActualizacion { get; set; }
    
    public {Status} Status { get; set; }
    public List<{RelatedEntity}> RelatedEntities { get; set; } = new();
}
```

### Auditor√≠a de Acciones
**Cada modificaci√≥n en la BD debe registrar:**
- `UsuarioInserto` - Usuario que cre√≥ el registro
- `UltimoUsuarioActualizo` - √öltimo usuario que modific√≥
- `FechaInsercion` - Fecha de creaci√≥n (SYSDATE en Oracle)
- `FechaActualizacion` - Fecha de √∫ltima actualizaci√≥n (SYSDATE en Oracle)

**El usuario debe provenir del contexto de autenticaci√≥n JWT:**
```csharp
var userId = JwtUserHelper.GetUserId(HttpContext.User);
await _repository.CreateAsync(entity, userId);
```

**Las fechas deben establecerse por trigger en Oracle (recomendado):**
```sql
CREATE OR REPLACE TRIGGER TRG_AUD_{TABLE_NAME}
BEFORE INSERT OR UPDATE ON {TABLE_NAME}
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        :NEW.FechaInsercion := SYSDATE;
        :NEW.UsuarioInserto := :NEW.UsuarioInserto;
    ELSIF UPDATING THEN
        :NEW.FechaActualizacion := SYSDATE;
        :NEW.UltimoUsuarioActualizo := :NEW.UltimoUsuarioActualizo;
    END IF;
END;
/
```

**O establecer en el c√≥digo C#:**
```csharp
public async Task<{Entity}> CreateAsync({Entity} entity, string currentUser)
{
    entity.UsuarioInserto = currentUser;
    entity.FechaInsercion = DateTimeHelper.GetMexicoDateTime();
    // ... resto de la l√≥gica ...
}
```

## üïê Manejo de Fechas y Zona Horaria (OBLIGATORIO)

### Regla Fundamental
**TODAS las APIs que guarden o muestren fechas DEBEN usar la zona horaria de M√©xico.**

### Helper de Fechas
**SIEMPRE usar `DateTimeHelper` de `Shared.Security` para fechas:**

```csharp
using Shared.Security;

// Para obtener DateTime (objetos, propiedades)
var fechaHora = DateTimeHelper.GetMexicoDateTime();

// Para obtener string formateado (respuestas JSON, logs)
var fechaHoraString = DateTimeHelper.GetMexicoTimeString();
```

### Uso en Controllers
**TODOS los campos `Timestamp` en respuestas API deben usar hora de M√©xico:**

```csharp
// ‚úÖ CORRECTO
return Ok(new ApiResponse<object>
{
    Success = true,
    Data = data,
    Timestamp = DateTimeHelper.GetMexicoTimeString()  // Para strings en JSON
});

// ‚úÖ CORRECTO (si el objeto necesita DateTime)
var stats = new
{
    ProcessId = process.Id,
    Timestamp = DateTimeHelper.GetMexicoDateTime()  // Para objetos DateTime
};
```

### Uso en Services
**Al crear o actualizar entidades con fechas:**

```csharp
// ‚úÖ CORRECTO
var entidad = new CargaArchivoSincronizacion
{
    Proceso = dto.Proceso,
    FechaCarga = DateTimeHelper.GetMexicoDateTime(),  // Hora de M√©xico
    // ...
};
```

### Uso en Repositories
**Al establecer fechas de auditor√≠a en c√≥digo (si no se usa trigger):**

```csharp
// ‚úÖ CORRECTO
entity.FechaInsercion = DateTimeHelper.GetMexicoDateTime();
entity.FechaActualizacion = DateTimeHelper.GetMexicoDateTime();
```

### Uso en Background Services
**Al registrar timestamps de ciclos y operaciones:**

```csharp
// ‚úÖ CORRECTO
_lastWarmupTime = DateTimeHelper.GetMexicoDateTime();
_lastHealthCheckTime = DateTimeHelper.GetMexicoDateTime();
```

### ‚ùå NUNCA usar:
```csharp
// ‚ùå INCORRECTO - Hora del servidor (puede ser diferente)
var fecha = DateTime.Now;

// ‚ùå INCORRECTO - Hora UTC (no es la hora de M√©xico)
var fecha = DateTime.UtcNow;

// ‚ùå INCORRECTO - Constructor sin zona horaria
var fecha = new DateTime(2025, 1, 1, 10, 0, 0);
```

### Reglas de Fechas
- ‚úÖ **TODAS las fechas en respuestas API** deben usar `DateTimeHelper.GetMexicoTimeString()` o `DateTimeHelper.GetMexicoDateTime()`
- ‚úÖ **TODAS las fechas guardadas en BD** deben usar `DateTimeHelper.GetMexicoDateTime()` (si se establecen en c√≥digo)
- ‚úÖ **TODOS los timestamps en logs** deben usar hora de M√©xico cuando sea relevante
- ‚úÖ **TODOS los campos `Timestamp` en `ApiResponse`** deben usar `DateTimeHelper.GetMexicoTimeString()`
- ‚úÖ **TODOS los campos de fecha en objetos de respuesta** deben usar `DateTimeHelper.GetMexicoDateTime()`
- ‚úÖ **Background services** deben usar `DateTimeHelper.GetMexicoDateTime()` para timestamps de ciclos

### Ejemplo Completo
```csharp
[HttpGet]
public async Task<IActionResult> GetStats()
{
    var stats = new
    {
        ProcessId = Process.GetCurrentProcess().Id,
        MemoryUsageMB = 150,
        Timestamp = DateTimeHelper.GetMexicoDateTime()  // ‚úÖ Hora de M√©xico
    };

    return Ok(new ApiResponse<object>
    {
        Success = true,
        Data = stats,
        Timestamp = DateTimeHelper.GetMexicoTimeString()  // ‚úÖ String formateado
    });
}
```

## ‚öôÔ∏è Configuraci√≥n de Program.cs

### Plantilla Base
```csharp
using {Company}.{Module}.Application.Services;
using {Company}.{Module}.Domain.Interfaces;
using {Company}.{Module}.Infrastructure.Repositories;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using Microsoft.OpenApi.Models;
using Scalar.AspNetCore;
using Serilog;
using Shared.Infrastructure;
using System.Text;

var builder = WebApplication.CreateBuilder(args);

// URLs fijas
builder.WebHost.UseUrls("https://localhost:5001", "http://localhost:5000");

// Serilog
Log.Logger = new LoggerConfiguration()
    .MinimumLevel.Information()
    .WriteTo.Console()
    .WriteTo.File("Logs/log-.txt", rollingInterval: RollingInterval.Day)
    .Enrich.FromLogContext()
    .CreateLogger();
builder.Host.UseSerilog();

// Servicios
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();

// Swagger
builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new OpenApiInfo
    {
        Title = "{Company} {Module} API",
        Version = "v1",
        Description = "API para {descripci√≥n del m√≥dulo}"
    });

    c.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
    {
        Description = "JWT Authorization header using the Bearer scheme",
        Name = "Authorization",
        In = ParameterLocation.Header,
        Type = SecuritySchemeType.ApiKey,
        Scheme = "Bearer"
    });

    c.AddSecurityRequirement(new OpenApiSecurityRequirement
    {
        {
            new OpenApiSecurityScheme
            {
                Reference = new OpenApiReference
                {
                    Type = ReferenceType.SecurityScheme,
                    Id = "Bearer"
                }
            },
            Array.Empty<string>()
        }
    });
});

// JWT
var jwtConfig = builder.Configuration.GetSection("Jwt").Get<JwtConfig>();
if (jwtConfig == null || string.IsNullOrWhiteSpace(jwtConfig.Key))
{
    throw new InvalidOperationException("La configuraci√≥n JWT no est√° completa en appsettings.json");
}

builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.RequireHttpsMetadata = false;
        options.SaveToken = true;
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtConfig.Key)),
            ValidateIssuer = !string.IsNullOrWhiteSpace(jwtConfig.Issuer),
            ValidIssuer = string.IsNullOrWhiteSpace(jwtConfig.Issuer) ? null : jwtConfig.Issuer,
            ValidateAudience = !string.IsNullOrWhiteSpace(jwtConfig.Audience),
            ValidAudience = string.IsNullOrWhiteSpace(jwtConfig.Audience) ? null : jwtConfig.Audience,
            ValidateLifetime = true
        };
    });

builder.Services.AddAuthorization();

// Oracle Connection Factory
var connectionString = builder.Configuration.GetConnectionString("Oracle");
if (string.IsNullOrWhiteSpace(connectionString))
{
    throw new InvalidOperationException("Connection string 'Oracle' no encontrada en appsettings.json");
}

builder.Services.AddScoped<IOracleConnectionFactory>(sp =>
    new OracleConnectionFactory(connectionString, sp.GetService<ILogger<OracleConnectionFactory>>()));

// Dependency Injection
builder.Services.AddScoped<I{Entity}Repository, {Entity}Repository>();
builder.Services.AddScoped<I{Entity}Service, {Entity}Service>();

// CORS
builder.Services.AddCors(options =>
{
    options.AddDefaultPolicy(policy =>
    {
        policy.AllowAnyOrigin()
              .AllowAnyMethod()
              .AllowAnyHeader();
    });
});

var app = builder.Build();

// Pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI(c =>
    {
        c.SwaggerEndpoint("/swagger/v1/swagger.json", "{Company} {Module} API v1");
        c.RoutePrefix = "swagger";
    });
    
    app.MapScalarApiReference(options =>
    {
        options
            .WithTitle("{Company} {Module} API")
            .WithDefaultHttpClient(ScalarTarget.CSharp, ScalarClient.HttpClient)
            .WithTheme(ScalarTheme.BluePlanet);
    });
}

if (app.Environment.IsDevelopment())
{
    app.UseHttpsRedirection();
}
app.UseCors();
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();

Log.Information("üöÄ {Company} {Module} API iniciada");
app.Run();

public class JwtConfig
{
    public string Key { get; set; } = string.Empty;
    public string Issuer { get; set; } = string.Empty;
    public string Audience { get; set; } = string.Empty;
    public string Subject { get; set; } = string.Empty;
}
```

## üîê Seguridad y Autenticaci√≥n

### JWT Helpers
Usar helpers de `Shared.Security`:
```csharp
var userId = JwtUserHelper.GetUserId(HttpContext.User);
var correlationId = CorrelationHelper.GetCorrelationId(HttpContext);
```

### Autorizaci√≥n
```csharp
[Authorize]
[HttpGet]
public async Task<ActionResult<ApiResponse<List<OrderDto>>>> GetOrders()
{
    // ...
}

[Authorize(Roles = "Admin")]
[HttpDelete("{id}")]
public async Task<ActionResult> DeleteOrder(int id)
{
    // ...
}
```

### Validaci√≥n de Inputs
**TODOS los inputs deben ser validados con DataAnnotations o FluentValidation:**

```csharp
public class CreateOrderDto
{
    [Required(ErrorMessage = "CustomerId es requerido")]
    [Range(1, int.MaxValue, ErrorMessage = "CustomerId debe ser mayor a 0")]
    public int CustomerId { get; set; }

    [Required(ErrorMessage = "Items es requerido")]
    [MinLength(1, ErrorMessage = "La orden debe contener al menos un item")]
    public List<OrderItemDto> Items { get; set; } = new();

    [MaxLength(500, ErrorMessage = "Las notas no pueden exceder 500 caracteres")]
    public string? Notes { get; set; }
}
```

### C√≥digos HTTP Est√°ndar
- `200 OK` ‚Üí Operaci√≥n exitosa
- `201 Created` ‚Üí Recurso creado
- `204 No Content` ‚Üí Operaci√≥n exitosa sin contenido
- `400 Bad Request` ‚Üí Error de validaci√≥n
- `401 Unauthorized` ‚Üí No autenticado
- `403 Forbidden` ‚Üí Sin permisos
- `404 Not Found` ‚Üí Recurso no encontrado
- `409 Conflict` ‚Üí Conflicto (ej: duplicado)
- `500 Internal Server Error` ‚Üí Error del servidor

### Seguridad - Reglas Cr√≠ticas
- ‚úÖ **NO exponer** excepciones internas ni mensajes de Oracle en las respuestas
- ‚úÖ **NO almacenar** credenciales en c√≥digo fuente
- ‚úÖ Usar **Azure Key Vault** o variables de entorno para secretos
- ‚úÖ Implementar **rate limiting** para prevenir abusos
- ‚úÖ Validar **TODOS** los inputs antes de procesar

## üìù Logging y Auditor√≠a con Serilog

### Configuraci√≥n de Serilog
**Serilog es el framework principal de logging en todas las APIs.**

Configurar en `Program.cs`:
```csharp
Log.Logger = new LoggerConfiguration()
    .MinimumLevel.Information()
    .WriteTo.Console()
    .WriteTo.File("Logs/log-.txt", rollingInterval: RollingInterval.Day)
    .Enrich.FromLogContext()
    .CreateLogger();

builder.Host.UseSerilog();
```

### Structured Logging por Capa

**Controller - Inicio, fin y resultado de cada request:**
```csharp
[HttpPost]
public async Task<ActionResult<ApiResponse<OrderDto>>> CreateOrder([FromBody] CreateOrderDto dto)
{
    var stopwatch = Stopwatch.StartNew();
    var correlationId = CorrelationHelper.GetCorrelationId(HttpContext);
    var userId = JwtUserHelper.GetUserId(HttpContext.User);

    _logger.LogInformation(
        "Inicio de creaci√≥n de orden. Usuario: {UserId}, CorrelationId: {CorrelationId}, Request: {@Request}",
        userId, correlationId, dto);

    try
    {
        var order = await _orderService.CreateOrderAsync(dto, userId, correlationId);
        
        stopwatch.Stop();
        _logger.LogInformation(
            "Orden {OrderId} creada exitosamente en {ElapsedMs}ms. Usuario: {UserId}",
            order.Id, stopwatch.ElapsedMilliseconds, userId);

        return CreatedAtAction(nameof(GetOrder), new { id = order.Id }, 
            ApiResponse<OrderDto>.Success(order));
    }
    catch (BusinessValidationException ex)
    {
        stopwatch.Stop();
        _logger.LogWarning(ex,
            "Error de validaci√≥n al crear orden en {ElapsedMs}ms. Usuario: {UserId}, Error: {Message}",
            stopwatch.ElapsedMilliseconds, userId, ex.Message);
        return BadRequest(ApiResponse<OrderDto>.Error(ex.Message));
    }
    catch (Exception ex)
    {
        stopwatch.Stop();
        _logger.LogError(ex,
            "Error inesperado al crear orden en {ElapsedMs}ms. Usuario: {UserId}",
            stopwatch.ElapsedMilliseconds, userId);
        return StatusCode(500, ApiResponse<OrderDto>.Error("Internal server error"));
    }
}
```

**Service - Operaciones de negocio relevantes:**
```csharp
public async Task<OrderDto> CreateOrderAsync(CreateOrderDto dto, string currentUser, string correlationId)
{
    _logger.LogInformation(
        "Inicio de m√©todo {Method} para usuario {User}. CorrelationId: {CorrelationId}",
        nameof(CreateOrderAsync), currentUser, correlationId);

    // Validaciones de negocio
    if (dto.Items == null || !dto.Items.Any())
    {
        _logger.LogWarning("Intento de crear orden sin items. Usuario: {User}", currentUser);
        throw new BusinessValidationException("La orden debe contener al menos un item");
    }

    // ... l√≥gica de negocio ...

    _logger.LogInformation(
        "Orden creada exitosamente. OrderId: {OrderId}, Usuario: {User}",
        order.Id, currentUser);

    return orderDto;
}
```

**Repository - Consultas ejecutadas, par√°metros y errores Oracle:**
```csharp
public async Task<Order?> GetByIdAsync(int id)
{
    const string query = "SELECT * FROM Orders WHERE Id = :Id";
    
    _logger.LogInformation("Ejecutando consulta {Query} con par√°metros {@Params}",
        nameof(GetByIdAsync), new { id });

    try
    {
        // ... ejecuci√≥n de consulta ...
        
        _logger.LogInformation("Consulta {Query} ejecutada exitosamente", nameof(GetByIdAsync));
        return order;
    }
    catch (OracleException ex)
    {
        _logger.LogError(ex, 
            "Error Oracle en {Method} con par√°metros {@Params}. ErrorCode: {ErrorCode}",
            nameof(GetByIdAsync), new { id }, ex.Number);
        throw new DataAccessException("Error al acceder a la base de datos", ex);
    }
}
```

### Los logs deben incluir SIEMPRE:
- ‚úÖ Nombre del m√©todo
- ‚úÖ Usuario autenticado (si aplica)
- ‚úÖ Identificador de correlaci√≥n (para trazabilidad)
- ‚úÖ Tiempo de ejecuci√≥n (usar `Stopwatch`)
- ‚úÖ Par√°metros de entrada (usar `@` para objetos complejos)

### Structured Logging - Ejemplos Correctos
```csharp
// ‚úÖ CORRECTO - Structured logging
_logger.LogInformation("Order {OrderId} created successfully by user {UserId}", orderId, userId);
_logger.LogError(ex, "Error creating order {OrderId} for user {UserId}", orderId, userId);
_logger.LogWarning("Order {OrderId} has low stock. Current stock: {Stock}", orderId, stock);

// ‚ùå INCORRECTO - String interpolation
_logger.LogInformation($"Order {orderId} created successfully");
_logger.LogError("Error creating order: " + ex.Message);
```

## ‚ö†Ô∏è Manejo de Errores y Excepciones

### Excepciones por Capa

**Repository - Capturar OracleException:**
```csharp
public async Task<{Entity}?> GetByIdAsync(int id)
{
    try
    {
        // ... operaci√≥n de BD ...
    }
    catch (OracleException ex)
    {
        _logger.LogError(ex, "Error Oracle en {Method} con par√°metros {@Params}",
            nameof(GetByIdAsync), new { id });
        throw new DataAccessException("Error al acceder a la base de datos", ex);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Error inesperado en {Method}", nameof(GetByIdAsync));
        throw;
    }
}
```

**Service - Capturar errores de negocio:**
```csharp
public async Task<{Entity}Dto> Create{Entity}Async(Create{Entity}Dto dto, string currentUser)
{
    try
    {
        // Validaciones de negocio
        if (dto.Property == null)
        {
            throw new BusinessValidationException("Property es requerido");
        }

        // ... l√≥gica de negocio ...
    }
    catch (BusinessValidationException)
    {
        // Re-lanzar excepciones de negocio
        throw;
    }
    catch (DataAccessException)
    {
        // Re-lanzar excepciones de acceso a datos
        throw;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Error inesperado en {Method}", nameof(Create{Entity}Async));
        throw new BusinessException("Error al procesar la operaci√≥n", ex);
    }
}
```

**Controller - Capturar excepciones globales:**
```csharp
[HttpPost]
public async Task<ActionResult<ApiResponse<{Entity}Dto>>> Create{Entity}([FromBody] Create{Entity}Dto dto)
{
    try
    {
        var userId = JwtUserHelper.GetUserId(HttpContext.User);
        var entity = await _{entity}Service.Create{Entity}Async(dto, userId);
        return CreatedAtAction(nameof(Get{Entity}), new { id = entity.Id }, 
            ApiResponse<{Entity}Dto>.Success(entity));
    }
    catch (BusinessValidationException ex)
    {
        return BadRequest(ApiResponse<{Entity}Dto>.Error(ex.Message));
    }
    catch (NotFoundException ex)
    {
        return NotFound(ApiResponse<{Entity}Dto>.Error(ex.Message));
    }
    catch (DataAccessException ex)
    {
        _logger.LogError(ex, "Error de acceso a datos");
        return StatusCode(500, ApiResponse<{Entity}Dto>.Error("Error al acceder a la base de datos"));
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Error inesperado");
        return StatusCode(500, ApiResponse<{Entity}Dto>.Error("Internal server error"));
    }
}
```

### Excepciones Espec√≠ficas de Shared.Exceptions
```csharp
// ‚úÖ CORRECTO
if (entity == null)
{
    throw new NotFoundException($"Entity with id {id} not found");
}

if (entity.Status == EntityStatus.Invalid)
{
    throw new BusinessValidationException("Cannot perform operation on invalid entity");
}

// ‚ùå INCORRECTO
throw new Exception("Entity not found");
```

### Middleware de Manejo de Excepciones Globales
```csharp
public class ExceptionHandlingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ExceptionHandlingMiddleware> _logger;

    public ExceptionHandlingMiddleware(RequestDelegate next, ILogger<ExceptionHandlingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (BusinessValidationException ex)
        {
            _logger.LogWarning(ex, "Business error: {Message}", ex.Message);
            await HandleExceptionAsync(context, ex, StatusCodes.Status400BadRequest);
        }
        catch (NotFoundException ex)
        {
            _logger.LogWarning(ex, "Not found error: {Message}", ex.Message);
            await HandleExceptionAsync(context, ex, StatusCodes.Status404NotFound);
        }
        catch (DataAccessException ex)
        {
            _logger.LogError(ex, "Data access error: {Message}", ex.Message);
            await HandleExceptionAsync(context, ex, StatusCodes.Status500InternalServerError);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unhandled error: {Message}", ex.Message);
            await HandleExceptionAsync(context, ex, StatusCodes.Status500InternalServerError);
        }
    }

    private static async Task HandleExceptionAsync(HttpContext context, Exception exception, int statusCode)
    {
        context.Response.StatusCode = statusCode;
        context.Response.ContentType = "application/json";

        var response = ApiResponse<object>.Error(exception.Message);
        await context.Response.WriteAsJsonAsync(response);
    }
}
```

**Registrar en Program.cs:**
```csharp
app.UseMiddleware<ExceptionHandlingMiddleware>();
```

## üîÑ Async/Await

### Siempre usar async/await
```csharp
public async Task<EntityDto> GetEntityByIdAsync(int id)
{
    return await _repository.GetByIdAsync(id);
}
```

### Sufijo Async
Todos los m√©todos as√≠ncronos deben terminar en `Async`:
- ‚úÖ `GetOrderByIdAsync`
- ‚úÖ `CreateOrderAsync`
- ‚ùå `GetOrderById`
- ‚ùå `CreateOrder`

## üì¶ Dependencias entre Capas

### Reglas de Dependencias
- **API** ‚Üí Application, Domain, Shared.*
- **Application** ‚Üí Domain, Shared.*
- **Domain** ‚Üí Solo Shared.Contracts (si es necesario)
- **Infrastructure** ‚Üí Domain, Shared.Infrastructure

### NO crear dependencias circulares
- Domain NO debe depender de Application o Infrastructure
- Application NO debe depender de Infrastructure

## üéØ Reglas Generales

1. **50-100 endpoints por m√≥dulo** (ideal)
2. **Nomenclatura consistente:** `{Company}.{Module}.{Layer}`
3. **Shared solo si 2+ m√≥dulos lo necesitan**
4. **Endpoints:** `/api/v1/{company}/{module}/{resource}` (kebab-case)
5. **Siempre usar `ApiResponse<T>` en controllers**
6. **Siempre usar async/await con sufijo `Async`**
7. **Siempre usar structured logging**
8. **Siempre usar excepciones espec√≠ficas del dominio**
9. **Cada API tiene sus propios `appsettings.json`**
10. **Siempre usar Dapper como ORM** - NO Entity Framework ni ADO.NET puro

## üìã Checklist de Revisi√≥n de C√≥digo

Antes de hacer commit, verificar:

### Arquitectura y Estructura
- [ ] ¬øNomenclatura correcta (`{Company}.{Module}.{Layer}`)?
- [ ] ¬øEstructura de carpetas correcta?
- [ ] ¬øDependencias entre capas correctas?
- [ ] ¬øNo hay dependencias circulares?

### C√≥digo y Convenciones
- [ ] ¬øUsa async/await correctamente?
- [ ] ¬øLos m√©todos async tienen sufijo `Async`?
- [ ] ¬øUso de `ApiResponse<T>` en controllers?
- [ ] ¬øRoute attributes con formato `/api/v1/{company}/{module}/{resource}`?
- [ ] ¬øValidaci√≥n de DTOs con DataAnnotations?

### Dapper + Oracle
- [ ] ¬øUsa Dapper (`QueryAsync`, `ExecuteAsync`) en lugar de `OracleCommand`?
- [ ] ¬øLas conexiones Oracle usan `using` y `CreateConnectionAsync`?
- [ ] ¬øLas queries est√°n parametrizadas con objetos an√≥nimos o `DynamicParameters`?
- [ ] ¬øUsa transacciones para operaciones m√∫ltiples?
- [ ] ¬øManeja `OracleException` correctamente?
- [ ] ¬øLos SELECT usan alias para mapear a propiedades de la entidad?

### Logging y Auditor√≠a
- [ ] ¬øHay logging en cada capa (Controller, Service, Repository)?
- [ ] ¬øUsa structured logging (NO string interpolation)?
- [ ] ¬øIncluye usuario, correlationId y tiempo de ejecuci√≥n?
- [ ] ¬øSe registra auditor√≠a (usuario + fecha)?

### Manejo de Errores
- [ ] ¬øLos errores se manejan correctamente por capa?
- [ ] ¬øUsa excepciones espec√≠ficas (NO `Exception` gen√©rica)?
- [ ] ¬øNO expone excepciones internas en respuestas?

### Seguridad
- [ ] ¬øImplementa autenticaci√≥n JWT?
- [ ] ¬øUsa `[Authorize]` donde corresponde?
- [ ] ¬øNO hay credenciales hardcodeadas?
- [ ] ¬øValidaci√≥n de inputs implementada?

### Documentaci√≥n
- [ ] ¬øLa documentaci√≥n Swagger est√° actualizada?
- [ ] ¬øLos nombres son descriptivos y consistentes?
- [ ] ¬øLos DTOs est√°n separados de las entidades?

## üö´ Anti-patrones a Evitar

### ‚ùå NUNCA hacer:

```csharp
// ‚ùå Usar OracleCommand en lugar de Dapper
using var command = new OracleCommand(sql, connection);
command.Parameters.Add(":Id", OracleDbType.Int32).Value = id;
using var reader = await command.ExecuteReaderAsync();

// ‚ùå SQL Injection vulnerability
string query = $"SELECT * FROM Users WHERE Id = {id}";

// ‚ùå Conexi√≥n sin using
var connection = new OracleConnection(_connectionString);
connection.Open();
// ... operaciones ...
// ¬°Conexi√≥n nunca se cierra!

// ‚ùå C√≥digo s√≠ncrono en API
public User GetUser(int id) { /* ... */ }

// ‚ùå Exponer excepciones internas
catch (Exception ex)
{
    return BadRequest(ex.ToString()); // ‚ùå MAL
}

// ‚ùå Sin logging
public async Task<User> GetUserAsync(int id)
{
    return await _repository.GetByIdAsync(id); // ‚ùå Sin logs
}

// ‚ùå Credenciales hardcodeadas
var connectionString = "User Id=admin;Password=123456;..."; // ‚ùå MAL

// ‚ùå String interpolation en logging
_logger.LogInformation($"Order {orderId} created"); // ‚ùå MAL

// ‚ùå Exception gen√©rica
throw new Exception("Error occurred"); // ‚ùå MAL

// ‚ùå Sin parametrizar consultas
command.CommandText = $"SELECT * FROM Users WHERE Id = {id}"; // ‚ùå MAL
```

### Reglas Generales a Evitar
- ‚ùå NO crear dependencias circulares
- ‚ùå NO poner l√≥gica de negocio en controllers
- ‚ùå NO poner l√≥gica de negocio en repositories
- ‚ùå NO usar `Exception` gen√©rica
- ‚ùå NO usar string interpolation en logging
- ‚ùå NO crear m√≥dulos con >100 endpoints
- ‚ùå NO poner c√≥digo espec√≠fico de m√≥dulo en Shared
- ‚ùå NO usar nombres inconsistentes
- ‚ùå NO mantener conexiones abiertas fuera de `using`
- ‚ùå NO exponer mensajes de Oracle en respuestas
- ‚ùå NO almacenar credenciales en c√≥digo fuente

## ‚úÖ Ejemplos de Estructura Correcta

### Controller
```csharp
[ApiController]
[Route("api/v1/gm/catalog-sync/products")]
public class ProductsController : ControllerBase
{
    private readonly IProductService _productService;
    private readonly ILogger<ProductsController> _logger;

    public ProductsController(IProductService productService, ILogger<ProductsController> logger)
    {
        _productService = productService;
        _logger = logger;
    }

    [HttpGet]
    public async Task<ActionResult<ApiResponse<List<ProductDto>>>> GetProducts()
    {
        var products = await _productService.GetAllProductsAsync();
        return Ok(ApiResponse<List<ProductDto>>.Success(products));
    }
}
```

### Service
```csharp
public class ProductService : IProductService
{
    private readonly IProductRepository _repository;
    private readonly ILogger<ProductService> _logger;

    public ProductService(IProductRepository repository, ILogger<ProductService> logger)
    {
        _repository = repository;
        _logger = logger;
    }

    public async Task<ProductDto?> GetProductByIdAsync(int id)
    {
        var product = await _repository.GetByIdAsync(id);
        if (product == null)
        {
            _logger.LogWarning("Product {ProductId} not found", id);
            return null;
        }
        return MapToDto(product);
    }
}
```

## üß© Principios Finales

Cursor debe garantizar que **TODAS** las APIs nuevas cumplan con:

- ‚úÖ Uso de **Dapper** como ORM (NO Entity Framework ni ADO.NET puro)
- ‚úÖ Uso de **Serilog** para logging principal
- ‚úÖ C√≥digo **as√≠ncrono**, limpio y desacoplado
- ‚úÖ Manejo correcto de **errores y excepciones** por capa
- ‚úÖ **Auditor√≠a** garantizada (fechas + usuario)
- ‚úÖ Conexiones Oracle **seguras y eficientes** (using, Dapper, parametrizadas)
- ‚úÖ Estructura **ordenada y mantenible**
- ‚úÖ Cumplimiento de est√°ndares **REST** y seguridad **JWT**
- ‚úÖ **Documentaci√≥n** completa con Swagger y Scalar
- ‚úÖ **Performance** optimizado (Dapper, connection pool, async)
- ‚úÖ **Validaci√≥n** de todos los inputs
- ‚úÖ **Structured logging** en todas las capas

## üìö Referencias

- Documentaci√≥n completa: `docs/ARCHITECTURE.md`
- Plantilla de m√≥dulos: `docs/MODULE_TEMPLATE.md`
- Convenciones de c√≥digo: `docs/CODING_CONVENTIONS.md`
- [Serilog Documentation](https://serilog.net/)
- [Oracle.ManagedDataAccess.Core](https://www.oracle.com/database/technologies/appdev/dotnet/odp.html)
- [ASP.NET Core Best Practices](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/best-practices)

